import { createClient } from '../utils/supabase/client'
import { Database } from '../types/supabase'

export interface Wedding extends Omit<Database['public']['Tables']['weddings']['Row'], 'content'> {
  // Helper to type the JSON content
  content: WeddingContent
  template?: Template // Join result
}

export type RSVP = Database['public']['Tables']['rsvps']['Row']
export type Template = Database['public']['Tables']['templates']['Row']

export interface WeddingContent {
  groom_name?: string
  bride_name?: string
  wedding_date?: string
  wedding_time?: string
  address?: string
  map_url?: string
  images?: string[]
  bank_name?: string
  account_number?: string
  account_name?: string
  // Allow flexible structure as JSONB
  [key: string]: any
}

// Hardcoded for demo purposes as requested in the plan
const DEMO_HOST_ID = 'b34c46c8-a9ef-4932-96c2-42a476d0a88b'

export const dataService = {
  supabase: createClient(),

  getWedding: async (): Promise<Wedding | null> => {
    const supabase = createClient()
    // Fetch wedding for the demo user
    // We join templates to get template info if needed, though mostly we just need wedding data
    const { data, error } = await supabase
      .from('weddings')
      .select('*, template:templates(*)')
      .eq('host_id', DEMO_HOST_ID)
      .single()

    if (error) {
      console.error('Error fetching wedding:', error)
      return null
    }

    return {
      ...data,
      content: (data.content as unknown as WeddingContent) || {}
    } as Wedding
  },

  updateWedding: async (weddingId: string, content: WeddingContent): Promise<Wedding | null> => {
    const supabase = createClient()
    const { data, error } = await supabase
      .from('weddings')
      .update({ content: content })
      .eq('id', weddingId)
      .select()
      .single()

    if (error) {
      console.error('Error updating wedding:', error)
      throw error
    }

    return {
      ...data,
      content: (data.content as unknown as WeddingContent) || {}
    } as Wedding
  },

  updateWeddingTemplate: async (weddingId: string, templateId: number): Promise<void> => {
    const supabase = createClient()
    const { error } = await supabase.from('weddings').update({ template_id: templateId }).eq('id', weddingId)

    if (error) {
      console.error('Error updating template:', error)
      throw error
    }
  },

  getRSVPs: async (weddingId: string): Promise<RSVP[]> => {
    const supabase = createClient()
    const { data, error } = await supabase
      .from('rsvps')
      .select('*')
      .eq('wedding_id', weddingId)
      .order('created_at', { ascending: false })

    if (error) {
      console.error('Error fetching RSVPs:', error)
      return []
    }
    return data
  },

  getTemplates: async (): Promise<Template[]> => {
    const supabase = createClient()
    const { data, error } = await supabase.from('templates').select('*')

    if (error) {
      console.error('Error fetching templates:', error)
      return []
    }
    return data
  },

  deployWedding: async (
    weddingId: string,
    templateBranch: string = 'theme-vintage'
  ): Promise<{ success: boolean; status: string }> => {
    try {
      const response = await fetch('/api/trigger-deploy', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ weddingId, templateBranch })
      })

      if (response.ok) {
        return { success: true, status: 'building' }
      } else {
        console.error('Deploy failed')
        return { success: false, status: 'failed' }
      }
    } catch (e) {
      return { success: false, status: 'failed' }
    }
  },

  exportRSVPs: async (weddingId: string): Promise<void> => {
    // For a real app, this would probably fetch a CSV generated by backend or generate client side
    console.log(`Exporting RSVPs for ${weddingId}`)
    alert('Export functionality would generate an Excel file here.')
  }
}
